Index: app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/MyAdapter.kt
===================================================================
diff --git a/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/MyAdapter.kt b/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/ExamRecyclerviewAdapter.kt
rename from app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/MyAdapter.kt
rename to app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/ExamRecyclerviewAdapter.kt
--- a/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/MyAdapter.kt	
+++ b/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/ExamRecyclerviewAdapter.kt	
@@ -1,16 +1,11 @@
 package com.Fachhochschulebib.fhb.pruefungsplaner
 
-import androidx.recyclerview.widget.RecyclerView
 import android.view.ViewGroup
 import android.view.LayoutInflater
-import com.Fachhochschulebib.fhb.pruefungsplaner.R
-import android.content.SharedPreferences
 import android.graphics.drawable.GradientDrawable
 import com.Fachhochschulebib.fhb.pruefungsplaner.data.AppDatabase
 import com.Fachhochschulebib.fhb.pruefungsplaner.data.TestPlanEntry
 import android.os.Looper
-import com.Fachhochschulebib.fhb.pruefungsplaner.MyAdapter
-import com.Fachhochschulebib.fhb.pruefungsplaner.CheckGoogleCalendar
 import android.content.ContentValues
 import android.content.Context
 import android.graphics.Color
@@ -21,6 +16,7 @@
 import android.util.Log
 import android.view.View
 import android.widget.*
+import androidx.recyclerview.widget.RecyclerView
 import java.lang.Exception
 import java.util.*
 
@@ -33,7 +29,17 @@
 //
 //
 //////////////////////////////
-class MyAdapter// private Intent calIntent;     // Provide a suitable constructor (depends on the kind of dataset)
+/**
+ * The [RecyclerView.Adapter] for the [RecyclerView], that shows the list of exams.
+ * It is given lists for every information seperately, where the items at a specific position
+ * hold information about one exam. E.g. the exam at index 0 has its information in every list at position 0.
+ *
+ * @author Alexander Lange
+ * @since 1.5
+ * @see RecyclerView
+ * @see RecyclerView.Adapter
+ */
+class ExamRecyclerviewAdapter// private Intent calIntent;     // Provide a suitable constructor (depends on the kind of dataset)
     (
     var modules: MutableList<String>,
     private val examinerAndSemester: List<String>,
@@ -44,7 +50,7 @@
     mLayout: RecyclerView.LayoutManager?,
     private val roomAdapter: List<String>,
     private val statusHintList: List<String>
-) : RecyclerView.Adapter<MyAdapter.ViewHolder>() {
+) : RecyclerView.Adapter<ExamRecyclerviewAdapter.ViewHolder>() {
     private var save = false
     private var moduleName: String? = null
     private var context: Context? = null
@@ -136,14 +142,14 @@
                             if (Integer.valueOf(selectedEntry?.id) == pruefid) {
                                 // Start Merlin Gürtler
                                 // Setze die Farbe des Icons
-                                holder.statusIcon.setColorFilter(Color.parseColor(selectedEntry?.color))
+                                holder.statusIcon.setColorFilter(Color.parseColor(selectedEntry?.color))//TODO Extract color
 
                                 //if (eintrag.getStatus().equals("final")) {
                                 //    holder.statusIcon.setColorFilter(Color.parseColor("#228B22"));
                                 //}
                                 // Ende Merlin Gürtler
                                 if (selectedEntry?.favorit == true) {
-                                    holder.ivicon.setColorFilter(Color.parseColor("#06ABF9"))
+                                    holder.ivicon.setColorFilter(Color.parseColor("#06ABF9"))//TODO Extract color
                                     // Toast.makeText(v.getContext(), "129", Toast.LENGTH_SHORT).show();
                                 }
                             }
Index: app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/Terminefragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.Fachhochschulebib.fhb.pruefungsplaner\r\n\r\nimport android.Manifest\r\nimport android.app.ProgressDialog\r\nimport android.content.Context\r\nimport androidx.recyclerview.widget.RecyclerView\r\nimport android.widget.TextView\r\nimport android.content.SharedPreferences\r\nimport com.Fachhochschulebib.fhb.pruefungsplaner.data.AppDatabase\r\nimport android.os.Looper\r\nimport android.os.Bundle\r\nimport com.Fachhochschulebib.fhb.pruefungsplaner.model.RetrofitConnect\r\nimport org.json.XML\r\nimport androidx.recyclerview.widget.LinearLayoutManager\r\nimport android.widget.LinearLayout\r\nimport androidx.recyclerview.widget.RecyclerView.OnChildAttachStateChangeListener\r\nimport androidx.recyclerview.widget.ItemTouchHelper\r\nimport androidx.core.content.ContextCompat\r\nimport android.content.pm.PackageManager\r\nimport android.os.Handler\r\nimport android.util.Log\r\nimport android.view.*\r\nimport androidx.core.app.ActivityCompat\r\nimport androidx.fragment.app.Fragment\r\nimport kotlinx.android.synthetic.main.termine.*\r\nimport kotlinx.android.synthetic.main.terminefragment.*\r\nimport org.json.JSONArray\r\nimport org.json.JSONException\r\nimport org.json.JSONObject\r\nimport java.io.BufferedInputStream\r\nimport java.io.BufferedReader\r\nimport java.io.InputStream\r\nimport java.io.InputStreamReader\r\nimport java.lang.Exception\r\nimport java.lang.StringBuilder\r\nimport java.net.HttpURLConnection\r\nimport java.net.URL\r\nimport java.text.SimpleDateFormat\r\nimport java.util.*\r\nimport kotlinx.coroutines.*\r\nimport java.lang.Runnable\r\n\r\n//////////////////////////////\r\n// Terminefragment\r\n//\r\n//\r\n//\r\n// autor:\r\n// inhalt:  Prüfungen aus der Klasse Prüfplaneintrag werden abgefragt und\r\n// zur Darstelllung an den Recycleview-Adapter übergeben\r\n// zugriffsdatum: 20.2.20\r\n//\r\n//\r\n//////////////////////////////\r\n/**\r\n * Class to maintain the view for all exams. Requests information about exams and fills the recyclerview with them.\r\n *\r\n * @since 1.5\r\n * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n */\r\nclass Terminefragment : Fragment() {\r\n\r\n    //region parameter\r\n    //UI\r\n    private var progressBar: ProgressDialog? = null\r\n    private var mLayout: RecyclerView.LayoutManager? = null\r\n    //TODO REMOVE private var date: String? = null\r\n    //TODO REMOVE private var month2: String? = null\r\n    //TODO REMOVE private var day2: String? = null\r\n    //TODO CHECK REMOVE private var positionOld = 0\r\n\r\n    //TODO REMOVE private var year2: String? = null\r\n    private var checkList: MutableList<Boolean> = ArrayList()\r\n\r\n    //Links to sharedPreferences\r\n    private var mSharedPreferencesValidation: SharedPreferences? = null\r\n    private var mSharedPreferencesPPServerAdress: SharedPreferences? = null\r\n    private var mSharedPreferencesExamineYear: SharedPreferences? = null\r\n\r\n    private var mSharedPreferencesPPeriode: SharedPreferences? = null\r\n\r\n    //Globaldata from sharedPreferences\r\n    private var serverAddress: String? = null\r\n    private var relativePPlanURL: String? = null\r\n    private var examineYear: String? = null\r\n    private var currentExaminePeriod: String? = null\r\n    private var returnCourse: String? = null\r\n    private var courseMain: String? = null\r\n\r\n    private var mAdapter: MyAdapter? = null\r\n\r\n    //Link to Room-Database\r\n    private var database: AppDatabase? = null\r\n\r\n    //Scopes\r\n    //IO-Scope,optimized for network and disk operations\r\n    private val scope_io =\r\n        CoroutineScope(CoroutineName(\"IO Scope\") + Dispatchers.IO)\r\n\r\n    //UI-Scope, improved for ui operations\r\n    private val scope_ui = CoroutineScope(CoroutineName(\"UI Scope\") + Dispatchers.Main)\r\n\r\n    //TODO Alexander Lange Start\r\n    var filterChangeListenerPosition: Int? = null\r\n    //TODO Alexander Lange End\r\n    //endregion\r\n\r\n    companion object {\r\n        var validation: String? = null\r\n    }\r\n\r\n    /**\r\n     * Overrides the onCreate()-Method, which is called first in the Fragment-LifeCycle.\r\n     * In this Method, the global parameter which are independent of the UI get initialized,\r\n     * like the App-SharedPreferences and the reference to the Room-Database\r\n     *\r\n     * @since 1.5\r\n     *\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     *\r\n     * @see Fragment.onCreate\r\n     */\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setHasOptionsMenu(true)\r\n\r\n        //Get access to the shared preferences\r\n        mSharedPreferencesValidation =\r\n            this@Terminefragment.context?.getSharedPreferences(\"validation\", 0)\r\n        mSharedPreferencesPPServerAdress = this@Terminefragment.context!!.getSharedPreferences(\r\n            \"Server_Address\",\r\n            Context.MODE_PRIVATE\r\n        )\r\n        mSharedPreferencesExamineYear =\r\n            this@Terminefragment.context?.getSharedPreferences(\"examineTermin\", 0)\r\n        mSharedPreferencesPPeriode =\r\n            context?.getSharedPreferences(\"currentPeriode\", Context.MODE_PRIVATE)\r\n\r\n        //Get content from shared preferences\r\n        relativePPlanURL =\r\n            mSharedPreferencesPPServerAdress?.getString(\"ServerRelUrlPath\", \"0\")\r\n        serverAddress = mSharedPreferencesPPServerAdress?.getString(\"ServerIPAddress\", \"0\")\r\n\r\n        //Get access to the Room-Database\r\n        database = AppDatabase.getAppDatabase(context!!)\r\n    }\r\n\r\n    /**\r\n     * Overrides the onCreateView()-Method. It sets the current view to the terminefragment-layout.\r\n     *\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     * @see Fragment.onCreateView\r\n     */\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater,\r\n        container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View? {\r\n        val v = inflater.inflate(R.layout.terminefragment, container, false)\r\n        return v\r\n    }\r\n\r\n    /**\r\n     * Overrides the onViewCreated()-Method, which is called in the Fragment LifeCycle right after the onCreateView()-Method.\r\n     * In this Method, the UI-Elements choose_course.xml-Layout are being initialized. This cannot be done in the onCreate()-Method,\r\n     * because the UI-Elements, which are directly accessed via synthetic imports\r\n     * are no instantiated in the onCreate()-Method yet.\r\n     *\r\n     * @return Returns the initialized view of this Fragment\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     * @see Fragment.onViewCreated\r\n     */\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        getCalendarPermission()\r\n\r\n        val courseMain = mSharedPreferencesValidation?.getString(\"selectedCourse\", \"0\")\r\n\r\n        updateDataFromServer()\r\n        enableSwipeToDelete()\r\n        initRecyclerview()\r\n\r\n        // LongOperation asynctask = new LongOperation();\r\n\r\n        // asynctask.execute(\"\");\r\n\r\n        //From onCreateView\r\n        //hinzufügen von recycleview\r\n        //TODO REMOVE recyclerView = v.findViewById<View>(R.id.recyclerView4) as RecyclerView\r\n        //TODO REMOVE currentPeriodeTextView = v.findViewById<View>(R.id.currentPeriode) as TextView\r\n\r\n\r\n        // Ende Merlin Gürtler\r\n\r\n        //Touchhelper für die Recyclerview-Komponente, zum Überprüfen, ob gescrollt wurde\r\n        //ItemTouchHelper itemTouchhelper = new ItemTouchHelper(swipeController);\r\n        //itemTouchhelper.attachToRecyclerView(recyclerView);\r\n\r\n        //initialisieren der UI-Komponenten\r\n        //TODO REMOVE calendar = v.findViewById<View>(R.id.caCalender) as CalendarView\r\n        //TODO REMOVE btnSearch = v.findViewById<View>(R.id.btnDatum) as Button\r\n\r\n        //Clicklistener für den Kalender,\r\n        //Es wird überprüft, welches Datum ausgewählt wurde.\r\n        //TODO Alexander Lange Start\r\n        table.Filter.onFilterChangedListener.add { OnFilterChanged() }\r\n        filterChangeListenerPosition = table.Filter.onFilterChangedListener.size - 1\r\n        //TODO Alexander Lange End\r\n\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * This Method is called when the fragment gets destroyed. Its the last called Method in the Fragment-Lifecycle.\r\n     * It needs to remove the Filter-Callback from the table.kt-class so it will no longer update when the filter is changed.\r\n     *\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     * @see Fragment.onDestroy\r\n     */\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        if (filterChangeListenerPosition != null) {\r\n            table.Filter.onFilterChangedListener.removeAt(filterChangeListenerPosition!!)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This Method checks, if the user already gave permission to access the Calendar,\r\n     * if not, he is ask to do so.\r\n     *\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     */\r\n    fun getCalendarPermission() {\r\n        // Start Merlin Gürtler\r\n        //Zugriffrechte für den GoogleKalender\r\n        //Id für den Google Kalender\r\n        val callbackId = 42\r\n        //Wert1: ID Google Kalender, Wert2: Rechte fürs Lesen, Wert3: Rechte fürs schreiben)\r\n        checkPermission(\r\n            callbackId,\r\n            Manifest.permission.READ_CALENDAR,\r\n            Manifest.permission.WRITE_CALENDAR\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Checks the Phone for a give permission.\r\n     * If the permission is not granted, the user is asked if he wants to grant permission.\r\n     *\r\n     * @param[callbackId] Id of Permission which called function\r\n     * @param[permissionsId] List of permissions that need to be requested\r\n     *\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     */\r\n    private fun checkPermission(callbackId: Int, vararg permissionsId: String) {\r\n        var permissions = true\r\n        for (p in permissionsId) {\r\n            permissions = (permissions\r\n                    && ContextCompat\r\n                .checkSelfPermission(this.context!!, p) == PackageManager.PERMISSION_GRANTED)\r\n        }\r\n        if (!permissions) ActivityCompat.requestPermissions(\r\n            this@Terminefragment.activity!!,\r\n            permissionsId,\r\n            callbackId\r\n        )\r\n    } // Ende Merlin Gürtler\r\n\r\n    // Start Merlin Gürtler\r\n    // Funktion um die Führende 0 hinzuzufügen\r\n    /**\r\n     * Used to format a date with leading zeros. Checks if the given number contains only one digit and then adds the zero.\r\n     * TODO Change with SimpleDatePattern\r\n     *\r\n     * @param[dateToFormat] The Number that needs to be formatted\r\n     * @return The formatted date\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     */\r\n    private fun formatDate(dateToFormat: String): String {\r\n        var dateToFormat = dateToFormat\r\n        if (dateToFormat.length == 1) {\r\n            dateToFormat = \"0$dateToFormat\"\r\n        }\r\n        return dateToFormat\r\n    }\r\n\r\n    // Ende Merlin Gürtler\r\n\r\n\r\n    // Ende Merlin Gürtler\r\n\r\n    /**\r\n     * Initializes the Recyclerview which shows the information about pending exams.\r\n     *\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     */\r\n    fun initRecyclerview() {\r\n        recyclerView4?.visibility = View.VISIBLE\r\n\r\n        // use this setting to\r\n        // improve performance if you know that changes\r\n        // in content do not change the layout size\r\n        // of the RecyclerView\r\n        recyclerView4?.setHasFixedSize(true)\r\n\r\n        //mSharedPreferences = v.getContext().getSharedPreferences(\"json6\", 0);\r\n        // use a linear layout manager\r\n        val layoutManager = LinearLayoutManager(view?.context)\r\n        recyclerView4?.layoutManager = layoutManager\r\n        mLayout = recyclerView4?.layoutManager\r\n        //AdapterPassed() TODO REMOVE\r\n        recyclerView4?.addOnItemTouchListener(\r\n            RecyclerItemClickListener(\r\n                activity,\r\n                object : RecyclerItemClickListener.OnItemClickListener {\r\n                    override fun onItemClick(view: View?, position: Int) {\r\n                        //TODO REMOVE val txtSecondScreen =\r\n                        //TODO REMOVE view!!.findViewById<View>(R.id.txtSecondscreen) as TextView\r\n                        val viewItem = recyclerView4?.layoutManager?.findViewByPosition(position)\r\n                        val layout1 =\r\n                            viewItem?.findViewById<View>(R.id.linearLayout) as LinearLayout\r\n                        layout1?.setOnClickListener { v1: View? ->\r\n                            Log.e(\"@@@@@\", \"\" + position)\r\n                            if (txtSecondscreen?.visibility == View.VISIBLE) {\r\n                                txtSecondscreen?.visibility = View.GONE\r\n                                checkList[position] = false\r\n                            } else {\r\n                                // Start Merlin Gürtler\r\n                                for (i in 0 until (recyclerView4?.childCount ?: 0)) {\r\n                                    val holder =\r\n                                        recyclerView4?.layoutManager?.findViewByPosition(i)\r\n                                    // Try and Catch, da die App crasht\r\n                                    // wenn das Element nicht im View Port ist\r\n                                    try {\r\n                                        val txtSecondScreen2 =\r\n                                            holder?.findViewById<View>(R.id.txtSecondscreen) as TextView\r\n                                        if (txtSecondScreen2?.visibility == View.VISIBLE) {\r\n                                            txtSecondScreen2?.visibility = View.GONE\r\n                                        }\r\n                                    } catch (e: Exception) {\r\n                                        Log.d(\"ERROR\", \"NOT IN VIEW PORT $e\")\r\n                                    }\r\n                                }\r\n                                // Ende Merlin Gürtler\r\n                                txtSecondscreen?.visibility = View.VISIBLE\r\n                                txtSecondscreen?.text = mAdapter?.giveString(position)\r\n                            }\r\n                        }\r\n                        //TODO CHECK REMOVE positionOld = position\r\n                    }\r\n                })\r\n        )\r\n        // Start Merlin Gürtler\r\n        recyclerView4?.addOnChildAttachStateChangeListener(object :\r\n            OnChildAttachStateChangeListener {\r\n            override fun onChildViewAttachedToWindow(view: View) {}\r\n\r\n            // Wenn ein Element den Viewport verlässt, wird\r\n            // der zweite Screen zu geklappt\r\n            override fun onChildViewDetachedFromWindow(view: View) {\r\n                //TODO REMOVE val txtSecondScreen = view.findViewById<View>(R.id.txtSecondscreen) as TextView\r\n                if (txtSecondscreen?.visibility == View.VISIBLE) {\r\n                    txtSecondscreen?.visibility = View.GONE\r\n                }\r\n            }\r\n        })\r\n        createView()\r\n    }\r\n\r\n    /**\r\n     * Updates the current local data with the data from the server.\r\n     * Can change the data in the recyclerview and the currentExamPeriod\r\n     * Shows a progressbar while loading the data.\r\n     *\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     */\r\n    fun updateDataFromServer() {\r\n        val globalVariable = this.context?.applicationContext as StartClass\r\n        if (!globalVariable.isShowNoProgressBar || globalVariable.isChangeFaculty) {\r\n            globalVariable.isShowNoProgressBar = true\r\n            globalVariable.isChangeFaculty = false\r\n            progressBar = ProgressDialog(\r\n                this@Terminefragment.context,\r\n                R.style.ProgressStyle\r\n            )\r\n\r\n            // Erstelle den Fortschrittsbalken\r\n            progressBar?.setMessage(this@Terminefragment.context!!.getString(R.string.load))\r\n            progressBar?.setProgressStyle(ProgressDialog.STYLE_SPINNER)\r\n            progressBar?.setCancelable(false)\r\n            // Zeige den Fortschrittsbalken\r\n            progressBar?.show()\r\n\r\n            scope_io.launch {\r\n                updatePruefperiode()\r\n                updateRoomDatabase()\r\n            }.invokeOnCompletion {\r\n                Handler(Looper.getMainLooper()).post(object : Runnable {\r\n                    override fun run() {\r\n                        createView()\r\n                    }\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the Room-Database. Checks if entries have to be removed or have to be loaded from the server.\r\n     *\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     */\r\n    fun updateRoomDatabase() {\r\n        val currentExamineYear = mSharedPreferencesExamineYear?.getString(\"currentTermin\", \"0\")\r\n        val retrofit = RetrofitConnect(relativePPlanURL!!)\r\n        // IDs der zu aktualisierenden Kurse\r\n        val courseIds = getUnknownCourseIds()\r\n        //Aktualisiere die notwendigen Kurse\r\n        // > 2 da auch bei einem leeren Json Array [] gesetzt werden\r\n        if (courseIds.toString().length > 2) {\r\n            if (database != null && context != null && currentExamineYear != null && !examineYear.isNullOrEmpty() && !currentExaminePeriod.isNullOrEmpty() && !serverAddress.isNullOrEmpty()) {\r\n                retrofit.UpdateUnkownCourses(\r\n                    context!!,\r\n                    database!!,\r\n                    examineYear!!,\r\n                    currentExaminePeriod!!,\r\n                    currentExamineYear,\r\n                    serverAddress!!,\r\n                    courseIds.toString()\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns a list of unknown courses that need to be updated\r\n     *\r\n     * @return A JSON-Array of courses that need to be updated.\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     */\r\n    private fun getUnknownCourseIds(): JSONArray {\r\n        var ret = JSONArray()\r\n        val courses = database?.userDao()?.allCourses\r\n\r\n        if (courses != null) {\r\n            //Durchlaufe alle Kurse\r\n            for (course in courses) {\r\n                try {\r\n\r\n                    val courseName = course?.courseName ?: \"\"\r\n\r\n                    //Prüfe ob Kurs ausgewählt wurde. Falls nicht, lösche TestplanEntries für diesen Kurs\r\n                    //aus der Room-Database\r\n                    if (course?.choosen == false) {\r\n                        // lösche nicht die Einträge der gewählten Studiengänge und Favorit\r\n                        val toDelete =\r\n                            database?.userDao()?.getEntriesByCourseName(courseName, false)\r\n                        database?.userDao()?.deleteEntry(toDelete)\r\n                    }\r\n                    //Prüfe ob Kurs ausgewählt ist und nur unfavorisierte Einträge enthält. Falls ja, füge\r\n                    //Ihn zu den zu aktualisierenden Kursen hinzu\r\n                    if (database?.userDao()?.getOneEntryByName(\r\n                            courseName,\r\n                            false\r\n                        ) == null && course?.choosen == true\r\n                    ) {\r\n                        val idJson = JSONObject()\r\n                        idJson.put(\"ID\", course.sgid)\r\n                        ret.put(idJson)\r\n                    }\r\n                } catch (e: JSONException) {\r\n                    e.printStackTrace()\r\n                }\r\n            }\r\n        }\r\n        return ret\r\n    }\r\n\r\n    /**\r\n     * Checks for a new exam period and updates the exam-data if necessary.\r\n     *\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     */\r\n    //TODO Shorten\r\n    fun updatePruefperiode() {\r\n\r\n        val mEditor: SharedPreferences.Editor?\r\n        val retrofit = RetrofitConnect(relativePPlanURL!!)\r\n        // Erhalte die gewählte Fakultät aus den Shared Preferences\r\n        val facultyId = mSharedPreferencesValidation?.getString(\"returnFaculty\", \"0\")\r\n        try {\r\n            //DONE (09/2020 LG) Aktuellen Prüftermin aus JSON-String herausfiltern!\r\n            //Heutiges Datum als Vergleichsdatum ermitteln und den Formatierer festlegen.\r\n            val now = GregorianCalendar()\r\n            val currentDate = now.time\r\n            val formatter = SimpleDateFormat(\"yyyy-MM-dd\")\r\n            var currentExamineDate: JSONObject? = null\r\n            var date: String\r\n            var facultyIdDB: String\r\n            var examineDate: Date?\r\n            var lastDayPp: Date?\r\n            var examineWeek: Int\r\n\r\n            val pruefperiodenObjects = getPruefperiondenObjects()\r\n\r\n            //Durch-Iterieren durch alle Prüfperioden-Objekte des JSON-Ergebnisses\r\n            for (i in 0 until pruefperiodenObjects.length()) {\r\n                currentExamineDate = pruefperiodenObjects.getJSONObject(i)\r\n                date = currentExamineDate[\"startDatum\"].toString()\r\n                facultyIdDB = currentExamineDate.getJSONObject(\"fbFbid\")[\"fbid\"].toString()\r\n                //Aus dem String das Datum herauslösen\r\n                date = date.substring(0, 10)\r\n                //und in ein Date-Objekt umwandeln\r\n                examineDate = formatter.parse(date)\r\n\r\n                // Erhalte die Anzahl der Wochen\r\n                examineWeek = currentExamineDate[\"PPWochen\"].toString().toInt()\r\n                val c = Calendar.getInstance()\r\n                c.time = examineDate\r\n                c.add(Calendar.DATE, 7 * examineWeek - 2) // Anzahl der Tage Klausurenphase\r\n                lastDayPp = formatter.parse(formatter.format(c.time))\r\n\r\n                //und mit dem heutigen Datum vergleichen.\r\n                //Die erste Prüfperioden dieser Iteration, die nach dem heutigen Datum\r\n                //liegt ist die aktuelle Prüfperiode!\r\n                // die Fakultäts id wird noch mit der gewählten Fakultät verglichen\r\n                if (currentDate.before(lastDayPp) && facultyId == facultyIdDB) break\r\n            }\r\n            examineWeek = currentExamineDate?.get(\"PPWochen\")?.toString()?.toInt() ?: 0\r\n            //1 --> 1. Termin; 2 --> 2. Termin des jeweiligen Semesters\r\n            //-------------------------------------------------------------------\r\n            //DONE (08/2020) Termin 1 bzw. 2 in den Präferenzen speichern\r\n            val mSharedPreferencesExamineTermin = context\r\n                ?.getSharedPreferences(\"examineTermin\", Context.MODE_PRIVATE)\r\n            val mEditorExaminePeriodAndYear = mSharedPreferencesValidation?.edit()\r\n            mEditorExaminePeriodAndYear?.putString(\r\n                \"examineYear\",\r\n                currentExamineDate?.get(\"PPJahr\")?.toString()\r\n            )\r\n            val mEditorTermin = mSharedPreferencesExamineTermin?.edit()\r\n            mEditorTermin?.putString(\r\n                \"currentTermin\",\r\n                currentExamineDate?.get(\"pruefTermin\")?.toString()\r\n            )\r\n            mEditorExaminePeriodAndYear?.putString(\r\n                \"currentPeriode\",\r\n                currentExamineDate?.get(\"pruefSemester\")?.toString()\r\n            )\r\n            mEditorExaminePeriodAndYear?.apply()\r\n            mEditorTermin?.apply() //Ausführen der Schreiboperation!\r\n            //-------------------------------------------------------------------\r\n            val currentPeriode = currentExamineDate?.get(\"startDatum\")?.toString()\r\n            val arrayCurrentPeriode = currentPeriode?.split(\"T\")?.toTypedArray()\r\n            val fmt = SimpleDateFormat(\"yyyy-MM-dd\")\r\n            val inputDate = fmt.parse(arrayCurrentPeriode?.get(0))\r\n\r\n            //erhaltenes Datum Parsen als Datum\r\n            val calendar: Calendar = GregorianCalendar()\r\n            calendar.time = inputDate\r\n            val year = calendar[Calendar.YEAR]\r\n            //Add one to month {0 - 11}\r\n            val month = calendar[Calendar.MONTH] + 1\r\n            val day = calendar[Calendar.DAY_OF_MONTH]\r\n            calendar.add(Calendar.DATE, 7 * examineWeek - 2)\r\n            val year2 = calendar[Calendar.YEAR]\r\n            //Add one to month {0 - 11}\r\n            val month2 = calendar[Calendar.MONTH] + 1\r\n            val day2 = calendar[Calendar.DAY_OF_MONTH]\r\n\r\n            //String Prüfperiode zum Anzeigen\r\n            val currentExamineDateFormatted = (context!!.getString(R.string.current)\r\n                    + formatDate(day.toString())\r\n                    + \".\" + formatDate(month.toString())\r\n                    + \".\" + year + context!!.getString(R.string.bis)\r\n                    + formatDate(day2.toString())\r\n                    + \".\" + formatDate(month2.toString())\r\n                    + \".\" + year2) // number of days to add;\r\n\r\n            //Prüfperiode für die Offline-Verwendung speichern\r\n            mEditor = mSharedPreferencesPPeriode?.edit()\r\n            val strJson = mSharedPreferencesPPeriode?.getString(\"currentPeriode\", \"0\")\r\n            if (strJson != null) {\r\n                if (strJson == currentExamineDateFormatted) {\r\n                } else {\r\n                    mEditor?.clear()\r\n                    mEditor?.apply()\r\n                    // Start Merlin Gürtler\r\n                    // Speichere das Start und Enddatum der Prüfperiode\r\n                    mEditor?.putString(\r\n                        \"startDate\", formatDate(day.toString())\r\n                                + \"/\" + formatDate(month.toString()) + \"/\" + formatDate(year.toString())\r\n                    )\r\n                    mEditor?.putString(\r\n                        \"endDate\", formatDate(day2.toString())\r\n                                + \"/\" + formatDate(month2.toString()) + \"/\" + formatDate(\r\n                            year2.toString()\r\n                        )\r\n                    )\r\n                    mEditor?.apply()\r\n                    // Ende Merlin Gürtler\r\n                    mEditor?.putString(\"currentPeriode\", currentExamineDateFormatted)\r\n                    mEditor?.apply()\r\n                }\r\n            }\r\n            // Ende Merlin Gürtler\r\n        } catch (e: Exception) {\r\n            Log.d(\"Output\", \"Konnte nicht die Pruefphase aktualisieren\")\r\n            //Keineverbindung();\r\n        }\r\n        // Nun aus Shared Preferences\r\n        // die Daten für die Periode aus den Shared Preferences\r\n        val sleepTime: Int\r\n        val examineYearThread = mSharedPreferencesValidation?.getString(\"examineYear\", \"0\")\r\n        val currentExaminePeriodThread =\r\n            mSharedPreferencesValidation?.getString(\"currentPeriode\", \"0\")\r\n        val currentExamineYearThread =\r\n            mSharedPreferencesExamineYear?.getString(\"currentTermin\", \"0\")\r\n        sleepTime = if (database?.userDao()?.getEntriesByCourseName(courseMain)?.size == 0\r\n            || currentExamineYearThread != database?.userDao()?.termin\r\n        ) {\r\n            database?.userDao()?.deleteTestPlanEntryAll()\r\n            retrofit.RetrofitWebAccess(\r\n                this@Terminefragment.context!!,\r\n                database!!,\r\n                examineYearThread!!,\r\n                currentExaminePeriodThread!!,\r\n                currentExamineYearThread!!,\r\n                serverAddress!!\r\n            )\r\n            3000\r\n        } else {\r\n            retrofit.retroUpdate(\r\n                this@Terminefragment.context!!,\r\n                database!!,\r\n                examineYearThread!!,\r\n                currentExaminePeriodThread!!,\r\n                currentExamineYearThread!!,\r\n                serverAddress\r\n            )\r\n            2000\r\n        }\r\n        try {\r\n            // Timeout für die Progressbar\r\n            Thread.sleep(sleepTime.toLong())\r\n        } catch (e: InterruptedException) {\r\n            e.printStackTrace()\r\n        }\r\n        progressBar?.dismiss()\r\n    }\r\n\r\n    /**\r\n     * Returns a list of all examperiods in the database.\r\n     *\r\n     * @return a JSONArray with all examperiods containing information. The Json-Objects contain data about the first day of the period, the semester (WiSe or SoSe), first or second period, weeknumber and faculty.\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     */\r\n    private fun getPruefperiondenObjects(): JSONArray {\r\n        val result = StringBuilder()\r\n\r\n        //DONE (08/2020 LG)\r\n        val address = serverAddress + relativePPlanURL + \"entity.pruefperioden\"\r\n        val url = URL(address)\r\n\r\n        /*\r\n                    HttpURLConnection anstelle Retrofit, um die XML/Json-Daten abzufragen!!!\r\n                 */\r\n        val urlConn = url.openConnection() as HttpURLConnection\r\n        urlConn.connectTimeout = 1000 * 10 // mTimeout is in seconds\r\n        try {\r\n            urlConn.connect()\r\n        } catch (e: Exception) {\r\n            Log.d(\"Output exception\", e.toString())\r\n        }\r\n\r\n        //Variablen zum lesen der erhaltenen werte\r\n        val inputStream: InputStream = BufferedInputStream(urlConn.inputStream)\r\n        val reader = BufferedReader(InputStreamReader(inputStream))\r\n        var line: String?\r\n        while (reader.readLine().also { line = it } != null) {\r\n            result.append(line)\r\n        }\r\n        var jsonObj: JSONObject? = null\r\n        try {\r\n            jsonObj = XML.toJSONObject(result.toString())\r\n        } catch (e: JSONException) {\r\n            e.printStackTrace()\r\n        }\r\n\r\n        //hinzufügen der erhaltenen JSONObject werte zum JSONArray\r\n        val x: Iterator<*> = jsonObj!!.keys()\r\n        val jsonArray = JSONArray()\r\n        while (x.hasNext()) {\r\n            val key = x.next() as String\r\n            jsonArray.put(jsonObj[key])\r\n        }\r\n        val examinePeriodArray = JSONArray()\r\n        for (i in 0 until jsonArray.length()) {\r\n            val jsonObject = jsonArray.getJSONObject(i)\r\n            examinePeriodArray.put(jsonObject[\"pruefperioden\"])\r\n        }\r\n        val arrayZuString = examinePeriodArray.toString()\r\n        val erstesUndletztesZeichenentfernen =\r\n            arrayZuString.substring(1, arrayZuString.length - 1)\r\n        return JSONArray(erstesUndletztesZeichenentfernen)\r\n    }\r\n\r\n\r\n// List<PruefplanEintrag> ppeList = datenbank.userDao().getEntriesByValidation(validation);\r\n    // Start Merlin Gürtler\r\n    /**\r\n     * Gets the Entries from the Room-Database and added them to the Recyclerview.\r\n     *\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     */\r\n    private fun createView() {\r\n        val moduleAndCourseList: MutableList<String> = ArrayList()\r\n        val examinerAndSemester: MutableList<String> = ArrayList()\r\n        val dateList: MutableList<String> = ArrayList()\r\n        val moduleList: MutableList<String> = ArrayList()\r\n        val idList: MutableList<String> = ArrayList()\r\n        val formList: MutableList<String> = ArrayList()\r\n        val roomList: MutableList<String> = ArrayList()\r\n        var statusMessage: MutableList<String> = ArrayList()\r\n\r\n\r\n        scope_io.launch {\r\n            examineYear = mSharedPreferencesValidation?.getString(\"examineYear\", \"0\")\r\n            currentExaminePeriod = mSharedPreferencesValidation?.getString(\"currentPeriode\", \"0\")\r\n            returnCourse = mSharedPreferencesValidation?.getString(\"returnCourse\", \"0\")\r\n            validation = examineYear + returnCourse + currentExaminePeriod\r\n            //val ppeList = database?.userDao()?.getEntriesByValidation(validation)\r\n            val ppeList = database?.userDao()?.allEntries\r\n            Log.d(\"validation\", ppeList?.size.toString())//TODO REMVOE\r\n            if (ppeList != null) {\r\n                for (entry in ppeList) {\r\n                    if (!table.Filter.validateFilter(context, entry)) {\r\n                        continue\r\n                    }\r\n                    moduleAndCourseList.add(\r\n                        \"\"\"${entry?.module}\r\n     ${entry?.course}\"\"\"\r\n                    )\r\n                    examinerAndSemester.add(\r\n                        entry?.firstExaminer\r\n                                + \" \" + entry?.secondExaminer\r\n                                + \" \" + entry?.semester + \" \"\r\n                    )\r\n                    dateList.add(entry?.date ?: \"\")\r\n                    moduleList.add(entry?.module ?: \"\")\r\n                    idList.add(entry?.id ?: \"\")\r\n                    formList.add(entry?.examForm ?: \"\")\r\n                    roomList.add(entry?.room ?: \"\")\r\n                    statusMessage.add(entry?.hint ?: \"\")\r\n                    checkList.add(true)\r\n                }\r\n            } // define an adapter\r\n            mAdapter = MyAdapter(\r\n                moduleAndCourseList,\r\n                examinerAndSemester,\r\n                dateList,\r\n                moduleList,\r\n                idList,\r\n                formList,\r\n                mLayout,\r\n                roomList,\r\n                statusMessage\r\n            )\r\n            Handler(Looper.getMainLooper()).post {\r\n                recyclerView4?.adapter = mAdapter\r\n                setPruefungszeitraum()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the text for the current period with content from shared preferences\r\n     *\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     */\r\n    fun setPruefungszeitraum() {\r\n        val strJson = mSharedPreferencesPPeriode?.getString(\"currentPeriode\", \"0\")\r\n        if (strJson != \"0\") {\r\n            currentPeriode?.text = strJson\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Refreshes the Recyclerview with new Filteroptions. It is appended to the Filter.onFilterChangedListener.\r\n     *\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     * @see table.Filter\r\n     * @see table.Filter.onFilterChangedListener\r\n     */\r\n    fun OnFilterChanged() {\r\n        scope_io.launch {\r\n            createView()\r\n            Log.d(\"Terminefragment.kt-OnFilterChanged\", \"Updated Filter\")\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables the functionality to swipe an entity from the recyclerview to favor or delete it\r\n     *\r\n     * @since 1.5\r\n     * @author Alexander Lange (E-Mail:alexander.lange@fh-bielefeld.de)\r\n     */\r\n    // Start Merlin Gürtler\r\n    private fun enableSwipeToDelete() {\r\n        // try and catch, da es bei einer\r\n        // Orientierungsänderung sonst zu\r\n        // einer NullPointerException kommt\r\n        try {\r\n            // Definiert den Listener\r\n            val swipeToDeleteCallback: swipeListener =\r\n                object : swipeListener(context!!, false) {\r\n                    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, i: Int) {\r\n                        val position = viewHolder.adapterPosition\r\n                        var isFavorite: Boolean? = null\r\n                        scope_ui.launch {\r\n                            isFavorite = mAdapter?.checkFavorite(viewHolder.adapterPosition)\r\n                        }.invokeOnCompletion {\r\n                            if (isFavorite == true) {\r\n                                mAdapter?.deleteFromFavorites(\r\n                                    position,\r\n                                    (viewHolder as MyAdapter.ViewHolder)\r\n                                )\r\n                            } else {\r\n                                mAdapter?.addToFavorites(\r\n                                    position,\r\n                                    (viewHolder as MyAdapter.ViewHolder)\r\n                                )\r\n                            }\r\n                            mAdapter?.notifyDataSetChanged()\r\n                        }\r\n                    }\r\n                }\r\n\r\n            // Setzt den Listener\r\n            val itemTouchhelper = ItemTouchHelper(swipeToDeleteCallback)\r\n            itemTouchhelper.attachToRecyclerView(recyclerView4)\r\n        } catch (e: Exception) {\r\n            Log.d(\"Error\", \"Orientation error$e\")\r\n        }\r\n    }\r\n\r\n//    TODO REMOVE\r\n//    fun AdapterPassed() {\r\n//        //TODO CHANGE TO COROUTINE\r\n//        Thread {\r\n//            createAdapter()\r\n//            Handler(Looper.getMainLooper()).post { // Merlin Gürtler\r\n//                // Aktiviert den swipe listener\r\n//            }\r\n//            // System.out.println(String.valueOf(userdaten.size()));\r\n//        }.start()\r\n//        //Datenbankaufruf\r\n//    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/Terminefragment.kt b/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/Terminefragment.kt
--- a/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/Terminefragment.kt	
+++ b/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/Terminefragment.kt	
@@ -87,7 +87,7 @@
     private var returnCourse: String? = null
     private var courseMain: String? = null
 
-    private var mAdapter: MyAdapter? = null
+    private var mAdapter: ExamRecyclerviewAdapter? = null
 
     //Link to Room-Database
     private var database: AppDatabase? = null
@@ -767,7 +767,7 @@
                     checkList.add(true)
                 }
             } // define an adapter
-            mAdapter = MyAdapter(
+            mAdapter = ExamRecyclerviewAdapter(
                 moduleAndCourseList,
                 examinerAndSemester,
                 dateList,
@@ -837,12 +837,12 @@
                             if (isFavorite == true) {
                                 mAdapter?.deleteFromFavorites(
                                     position,
-                                    (viewHolder as MyAdapter.ViewHolder)
+                                    (viewHolder as ExamRecyclerviewAdapter.ViewHolder)
                                 )
                             } else {
                                 mAdapter?.addToFavorites(
                                     position,
-                                    (viewHolder as MyAdapter.ViewHolder)
+                                    (viewHolder as ExamRecyclerviewAdapter.ViewHolder)
                                 )
                             }
                             mAdapter?.notifyDataSetChanged()
Index: app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/TermineFragmentSearch.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.Fachhochschulebib.fhb.pruefungsplaner\r\n\r\nimport android.app.AlertDialog\r\nimport android.content.Context\r\nimport android.content.SharedPreferences\r\nimport androidx.recyclerview.widget.RecyclerView\r\nimport android.os.Bundle\r\nimport android.os.Handler\r\nimport android.widget.TextView\r\nimport androidx.recyclerview.widget.LinearLayoutManager\r\nimport com.Fachhochschulebib.fhb.pruefungsplaner.data.AppDatabase\r\nimport android.os.Looper\r\nimport android.util.Log\r\nimport android.view.*\r\nimport android.widget.Button\r\nimport android.widget.LinearLayout\r\nimport androidx.fragment.app.Fragment\r\nimport androidx.recyclerview.widget.RecyclerView.OnChildAttachStateChangeListener\r\nimport androidx.recyclerview.widget.ItemTouchHelper\r\nimport kotlinx.android.synthetic.main.termine.*\r\nimport kotlinx.android.synthetic.main.terminefragment.*\r\nimport java.lang.Exception\r\nimport java.util.ArrayList\r\n\r\n//////////////////////////////\r\n// TerminefragmentSuche\r\n//\r\n//\r\n//\r\n// autor:\r\n// inhalt:  Prüfungen aus der Klasse Prüfplaneintrag werden abgefragt und zur darstelllung an den Recycleview adapter übergeben\r\n// zugriffsdatum: 20.2.20\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//////////////////////////////\r\nclass TermineFragmentSearch : Fragment() {\r\n    var mSharedPreferencesValidation: SharedPreferences? = null\r\n    private var date: String? = null\r\n    var examineYear: String? = null\r\n    var currentExaminePeriod: String? = null\r\n    var returnCourse: String? = null\r\n    var validation: String? = null\r\n    var checkList: MutableList<Boolean> = ArrayList()\r\n    var moduleAndCourseList: MutableList<String> = ArrayList()\r\n    var examinerAndSemester: MutableList<String> = ArrayList()\r\n    var dateList: MutableList<String> = ArrayList()\r\n    var moduleList: MutableList<String> = ArrayList()\r\n    var idList: MutableList<String> = ArrayList()\r\n    var formList: MutableList<String> = ArrayList()\r\n    var roomList: MutableList<String> = ArrayList()\r\n    var statusList: MutableList<String> = ArrayList()\r\n    private var month2: String? = null\r\n    private var day2: String? = null\r\n\r\n    // private int position2 = 0;\r\n    private var year2: String? = null\r\n    private var mLayout: RecyclerView.LayoutManager? = null\r\n    var mAdapter: MyAdapter? = null\r\n    var valuesToShowList: MutableList<Int> = ArrayList()\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n\r\n        super.onCreate(savedInstanceState)\r\n    }\r\n\r\n    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {\r\n        inflater.inflate(R.menu.action_menu, menu);\r\n\r\n        super.onCreateOptionsMenu(menu, inflater)\r\n    }\r\n\r\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\r\n        super.onOptionsItemSelected(item)\r\n        when(item.itemId)\r\n        {\r\n            R.id.menu_item_filter-> OpenFilterMenu()\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    private fun OpenFilterMenu() {\r\n        val view = layoutInflater.inflate(R.layout.layout_dialog_filter,null)\r\n        val dialog = AlertDialog.Builder(context)\r\n            .setView(view)\r\n            .create()\r\n        dialog.show()\r\n    }\r\n\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        super.onViewCreated(view, savedInstanceState)\r\n        //From onCreate\r\n        // Start Merlin Gürtler\r\n        // Nun aus Shared Preferences\r\n        mSharedPreferencesValidation = this@TermineFragmentSearch.context\r\n            ?.getSharedPreferences(\"validation\", 0)\r\n        examineYear = mSharedPreferencesValidation?.getString(\"examineYear\", \"0\")\r\n        currentExaminePeriod = mSharedPreferencesValidation?.getString(\"currentPeriode\", \"0\")\r\n        returnCourse = mSharedPreferencesValidation?.getString(\"returnCourse\", \"0\")\r\n        validation = examineYear + returnCourse + currentExaminePeriod\r\n        // Ende Merlin Gürtler\r\n\r\n        //From onCreateView\r\n        //hinzufügen von recycleview\r\n        //TODO REMOVE recyclerView = v.findViewById<View>(R.id.recyclerView4) as RecyclerView\r\n        //TODO REMOVE val currentPeriodeTextView = v.findViewById<View>(R.id.currentPeriode) as TextView\r\n        val mSharedPreferencesPPeriode =\r\n            context?.getSharedPreferences(\"currentPeriode\", Context.MODE_PRIVATE)\r\n        val strJson = mSharedPreferencesPPeriode?.getString(\"currentPeriode\", \"0\")\r\n        currentPeriode.text = strJson\r\n        recyclerView4.visibility = View.VISIBLE\r\n        // use this setting to\r\n        // improve performance if you know that changes\r\n        // in content do not change the layout size\r\n        // of the RecyclerView\r\n        recyclerView4.setHasFixedSize(true)\r\n\r\n        // use a linear layout manager\r\n        val layoutManager = LinearLayoutManager(view.context)\r\n        recyclerView4.layoutManager = layoutManager\r\n        mLayout = recyclerView4.layoutManager\r\n\r\n\r\n        //Userinterface Komponenten Initialiseren\r\n        // recyclerView = (RecyclerView) v.findViewById(R.id.recyclerView4);\r\n        // recyclerView.setVisibility(View.VISIBLE);\r\n        //TODO REMOVE calendar = v.findViewById<View>(R.id.caCalender) as CalendarView\r\n\r\n        adapterPassed()\r\n        recyclerView4?.addOnItemTouchListener(\r\n            RecyclerItemClickListener(\r\n                activity,\r\n                object : RecyclerItemClickListener.OnItemClickListener {\r\n                    override fun onItemClick(view: View?, position: Int) {\r\n                        val txtSecondScreen =\r\n                            view!!.findViewById<View>(R.id.txtSecondscreen) as TextView\r\n                        val viewItem = recyclerView4?.layoutManager?.findViewByPosition(position)\r\n                        val layout1 =\r\n                            viewItem?.findViewById<View>(R.id.linearLayout) as LinearLayout\r\n                        layout1.setOnClickListener {\r\n                            Log.e(\"@@@@@\", \"\" + position)\r\n                            if (txtSecondScreen.visibility == View.VISIBLE) {\r\n                                txtSecondScreen.visibility = View.GONE\r\n                                checkList[position] = false\r\n                            } else {\r\n                                // Start Merlin Gürtler\r\n                                for (i in 0 until recyclerView4?.childCount!!) {\r\n                                    val holder = recyclerView4?.layoutManager\r\n                                        ?.findViewByPosition(i)\r\n                                    // Try and Catch, da die App crasht\r\n                                    // wenn das Element nicht im View Port ist\r\n                                    try {\r\n                                        val txtSecondScreen2 =\r\n                                            holder?.findViewById<View>(R.id.txtSecondscreen) as TextView\r\n                                        if (txtSecondScreen2.visibility == View.VISIBLE) {\r\n                                            txtSecondScreen2.visibility = View.GONE\r\n                                        }\r\n                                    } catch (e: Exception) {\r\n                                        Log.d(\"ERROR\", \"NOT IN VIEW PORT $e\")\r\n                                    }\r\n                                }\r\n                                // Ende Merlin Gürtler\r\n                                txtSecondScreen.visibility = View.VISIBLE\r\n                                txtSecondScreen.text = mAdapter?.giveString(position)\r\n                            }\r\n                        }\r\n                    }\r\n                })\r\n        )\r\n\r\n        // Start Merlin Gürtler\r\n        recyclerView4?.addOnChildAttachStateChangeListener(object :\r\n            OnChildAttachStateChangeListener {\r\n            override fun onChildViewAttachedToWindow(view: View) {}\r\n\r\n            // Wenn ein Element den Viewport verlässt, wird\r\n            // der zweite Screen zu geklappt\r\n            override fun onChildViewDetachedFromWindow(view: View) {\r\n                //TODO REMVOE val txtSecondScreen = view.findViewById<View>(R.id.txtSecondscreen) as TextView\r\n                if (txtSecondscreen?.visibility == View.VISIBLE) {\r\n                    txtSecondscreen?.visibility = View.GONE\r\n                }\r\n            }\r\n        })\r\n        // Ende Merlin Gürtler\r\n    }\r\n\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater, container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View? {\r\n        val v = inflater.inflate(R.layout.terminefragment, container, false)\r\n\r\n\r\n\r\n        return v\r\n    }\r\n\r\n    fun adapterPassed() {\r\n        //TODO CHANGE TO COROUTINE\r\n        Thread { //Datenbank initialisieren\r\n            val database = AppDatabase.getAppDatabase(context!!)\r\n\r\n            // Änderung Merlin Gürtler\r\n            // List<Pruefplan> pruefplandaten = datenbank.userDao().getEntriesByValidation(validation);\r\n            // Für die Suche von Modulen\r\n            val ppeList = database?.userDao()?.getAllChoosen(true)\r\n            // Ende Änderung Merlin Gürtler\r\n            ClearLists()\r\n            for (i in ppeList?.indices!!) {\r\n                valuesToShowList.add(i)\r\n            }\r\n\r\n            //Variablen mit Werten aus der lokalen Datenbank füllen\r\n            for (i in valuesToShowList.indices) {\r\n                moduleAndCourseList.add(\r\n                    \"\"\"${ppeList?.get(valuesToShowList[i])?.module}\r\n \"\"\" + ppeList?.get(\r\n     Integer.valueOf(\r\n         valuesToShowList[i]\r\n     )\r\n                    )?.course\r\n                )\r\n                examinerAndSemester.add(\r\n                    ppeList?.get(valuesToShowList[i])?.firstExaminer + \" \" + ppeList?.get(\r\n                        Integer.valueOf(\r\n                            valuesToShowList[i]\r\n                        )\r\n                    )?.secondExaminer + \" \" + ppeList?.get(Integer.valueOf(valuesToShowList[i]))?.semester + \" \"\r\n                )\r\n                dateList.add(ppeList?.get(valuesToShowList[i])?.date?:\"\")\r\n                moduleList.add(ppeList?.get(valuesToShowList[i])?.module?:\"\")\r\n                idList.add(ppeList?.get(valuesToShowList[i])?.id?:\"\")\r\n                formList.add(ppeList?.get(valuesToShowList[i])?.examForm ?:\"\")\r\n                roomList.add(ppeList?.get(valuesToShowList[i])?.room?:\"\")\r\n                statusList.add(ppeList?.get(valuesToShowList[i])?.hint?:\"\")\r\n                checkList.add(true)\r\n            }\r\n\r\n            // define an adapter\r\n            mAdapter = MyAdapter(\r\n                moduleAndCourseList,\r\n                examinerAndSemester,\r\n                dateList,\r\n                moduleList,\r\n                idList,\r\n                formList,\r\n                mLayout,\r\n                roomList,\r\n                statusList\r\n            )\r\n            Handler(Looper.getMainLooper()).post {\r\n                recyclerView4?.adapter = mAdapter\r\n                enableSwipeToDelete()\r\n            }\r\n        }.start()\r\n    }\r\n\r\n    fun ClearLists() {\r\n        moduleAndCourseList.clear()\r\n        examinerAndSemester.clear()\r\n        dateList.clear()\r\n        moduleList.clear()\r\n        idList.clear()\r\n        formList.clear()\r\n        roomList.clear()\r\n        statusList.clear()\r\n    }\r\n\r\n    // Start Merlin Gürtler\r\n    private fun enableSwipeToDelete() {\r\n        // try and catch, da es bei einer\r\n        // Orientierungsänderung sonst zu\r\n        // einer NullPointerException kommt\r\n        try {\r\n            // Definiert den Listener\r\n            val swipeToDeleteCallback: swipeListener = object : swipeListener(context!!, false) {\r\n                override fun onSwiped(viewHolder: RecyclerView.ViewHolder, i: Int) {\r\n                    val position = viewHolder.adapterPosition\r\n                    //TODO CHANGE TO COROUTINE\r\n                    Thread {\r\n                        val isFavorite = mAdapter?.checkFavorite(viewHolder.adapterPosition)\r\n                        Handler(Looper.getMainLooper()).post {\r\n                            if (isFavorite == true) {\r\n                                mAdapter?.deleteFromFavorites(\r\n                                    position,\r\n                                    (viewHolder as MyAdapter.ViewHolder)\r\n                                )\r\n                            } else {\r\n                                mAdapter?.addToFavorites(\r\n                                    position,\r\n                                    (viewHolder as MyAdapter.ViewHolder)\r\n                                )\r\n                            }\r\n                            mAdapter?.notifyDataSetChanged()\r\n                        }\r\n                    }.start()\r\n                }\r\n            }\r\n\r\n            // Setzt den Listener\r\n            val itemTouchhelper = ItemTouchHelper(swipeToDeleteCallback)\r\n            itemTouchhelper.attachToRecyclerView(recyclerView4)\r\n        } catch (e: Exception) {\r\n            Log.d(\"Error\", \"Orientation error$e\")\r\n        }\r\n    } // Ende Merlin Gürtler\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/TermineFragmentSearch.kt b/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/TermineFragmentSearch.kt
--- a/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/TermineFragmentSearch.kt	
+++ b/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/TermineFragmentSearch.kt	
@@ -12,7 +12,6 @@
 import android.os.Looper
 import android.util.Log
 import android.view.*
-import android.widget.Button
 import android.widget.LinearLayout
 import androidx.fragment.app.Fragment
 import androidx.recyclerview.widget.RecyclerView.OnChildAttachStateChangeListener
@@ -59,7 +58,7 @@
     // private int position2 = 0;
     private var year2: String? = null
     private var mLayout: RecyclerView.LayoutManager? = null
-    var mAdapter: MyAdapter? = null
+    var mAdapter: ExamRecyclerviewAdapter? = null
     var valuesToShowList: MutableList<Int> = ArrayList()
     override fun onCreate(savedInstanceState: Bundle?) {
 
@@ -241,7 +240,7 @@
             }
 
             // define an adapter
-            mAdapter = MyAdapter(
+            mAdapter = ExamRecyclerviewAdapter(
                 moduleAndCourseList,
                 examinerAndSemester,
                 dateList,
@@ -287,12 +286,12 @@
                             if (isFavorite == true) {
                                 mAdapter?.deleteFromFavorites(
                                     position,
-                                    (viewHolder as MyAdapter.ViewHolder)
+                                    (viewHolder as ExamRecyclerviewAdapter.ViewHolder)
                                 )
                             } else {
                                 mAdapter?.addToFavorites(
                                     position,
-                                    (viewHolder as MyAdapter.ViewHolder)
+                                    (viewHolder as ExamRecyclerviewAdapter.ViewHolder)
                                 )
                             }
                             mAdapter?.notifyDataSetChanged()
Index: app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/Optionen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.Fachhochschulebib.fhb.pruefungsplaner\r\n\r\nimport android.app.Activity\r\nimport android.content.SharedPreferences\r\nimport android.os.Bundle\r\nimport android.view.LayoutInflater\r\nimport android.view.ViewGroup\r\nimport com.Fachhochschulebib.fhb.pruefungsplaner.R\r\nimport com.Fachhochschulebib.fhb.pruefungsplaner.data.AppDatabase\r\nimport com.Fachhochschulebib.fhb.pruefungsplaner.data.TestPlanEntry\r\nimport com.Fachhochschulebib.fhb.pruefungsplaner.CheckGoogleCalendar\r\nimport android.os.Looper\r\nimport com.Fachhochschulebib.fhb.pruefungsplaner.PrivacyDeclarationFragment\r\nimport com.Fachhochschulebib.fhb.pruefungsplaner.model.RetrofitConnect\r\nimport android.content.ContentValues\r\nimport android.content.Context\r\nimport android.content.res.Resources\r\nimport android.graphics.Color\r\nimport android.graphics.Paint\r\nimport android.net.Uri\r\nimport android.os.Handler\r\nimport android.provider.CalendarContract\r\nimport android.util.Log\r\nimport android.util.TypedValue\r\nimport android.view.View\r\nimport android.widget.*\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport androidx.appcompat.app.AppCompatDelegate\r\nimport androidx.core.app.ActivityCompat\r\nimport androidx.fragment.app.Fragment\r\nimport kotlinx.android.synthetic.main.optionfragment.*\r\nimport org.json.JSONArray\r\nimport org.json.JSONException\r\nimport java.lang.Exception\r\nimport java.net.HttpURLConnection\r\nimport java.net.URL\r\nimport java.util.*\r\nimport androidx.core.app.ActivityCompat.recreate\r\nimport kotlinx.android.synthetic.main.optionfragment.view.*\r\n\r\n\r\n//////////////////////////////\r\n// Optionen\r\n//\r\n//\r\n//\r\n// autor:\r\n// inhalt:  Abfragen ob prüfungen zum Kalender hinzugefügt werden sollen  und Methoden zum löschen, aktualisieren der Datenbank\r\n// zugriffsdatum: 20.2.20\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//////////////////////////////\r\nclass Optionen() : Fragment() {\r\n    private var save = false\r\n    private var response: JSONArray? = null\r\n    private var calDate = GregorianCalendar()\r\n    private var course: String? = null\r\n    var mSharedPreferencesCurrentTermin: SharedPreferences? = null\r\n    private var currentTermin: String? = null\r\n\r\n    companion object {\r\n        val idList: List<String> = ArrayList()\r\n    }\r\n\r\n    //DONE: 08/2020 LG\r\n    var serverAddress: String? = null\r\n    var relativePPlanURL: String? = null\r\n    var examineYear: String? = null\r\n    var currentExaminePeriod: String? = null\r\n    var returnCourse: String? = null\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n    }\r\n\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        super.onViewCreated(view, savedInstanceState)\r\n        //From onCreate\r\n\r\n        //From onCreateView\r\n        //TODO Implement Settings Preferences\r\n        //TODO Alexander Lange Start\r\n        /*if (night_mode.equals(AppCompatDelegate.MODE_NIGHT_YES)) {\r\n            darkMode?.isSelected = true\r\n        }*/\r\n\r\n        theme.onItemSelectedListener = object :\r\n            AdapterView.OnItemSelectedListener {\r\n            override fun onItemSelected(\r\n                parent: AdapterView<*>,\r\n                view: View, position: Int, id: Long\r\n            ) {\r\n                when (position) {\r\n                    0 -> view.context.theme.applyStyle(R.style.Theme_AppTheme_1,false)\r\n                    1 -> view.context.theme.applyStyle(R.style.Theme_AppTheme_2,false)\r\n                }\r\n            }\r\n\r\n            override fun onNothingSelected(parent: AdapterView<*>) {\r\n                // write code to perform some action\r\n            }\r\n        }\r\n\r\n        val theme1 = Theme(R.style.Theme_AppTheme_1,view)\r\n        val theme2 = Theme(R.style.Theme_AppTheme_2,view)\r\n        val adapter = ThemeAdapter(view.context,R.layout.layout_theme_spinner_row,mutableListOf(theme1,theme2))\r\n        theme.adapter = adapter\r\n        //TODO Alexander Lange End\r\n\r\n        //Button zum updaten der Prüfungen\r\n        val btngo2 = view.findViewById<View>(R.id.btnupdate) as Button\r\n        btngo2.setOnClickListener(View.OnClickListener {\r\n            val validation = examineYear + returnCourse + currentExaminePeriod\r\n            updatePlan(validation)\r\n        })\r\n\r\n        //layout Komponenten\r\n        //TODO REMOVE val btnDb = v.findViewById<View>(R.id.btnDB) as Button\r\n        //TODO REMOVE val btnFav = v.findViewById<View>(R.id.btnFav) as Button\r\n        //TODO REMOVE val btnGoogleloeschen = v.findViewById<View>(R.id.btnCalClear) as Button\r\n        //TODO REMOVE val btnGoogleupdate = v.findViewById<View>(R.id.btnGoogleUpdate) as Button\r\n        //TODO REMOVE val SWgooglecalender = v.findViewById<View>(R.id.switch2) as Switch\r\n        //TODO REMOVE val privacyDeclaration = v.findViewById<View>(R.id.privacyDeclaration) as Button\r\n        //holder.zahl1 = position;\r\n        val serverAdresse = view.context.getSharedPreferences(\"json8\", 0)\r\n        //Creating editor to store uebergebeneModule to shared preferences\r\n        val mEditorGoogleCalendar = serverAdresse.edit()\r\n        val mSharedPreferencesPPServerAddress =\r\n            view.context.getSharedPreferences(\"Server_Address\", 0)\r\n        //Creating editor to store uebergebeneModule to shared preferences\r\n\r\n        //------------------------------------------------------------------\r\n        //DONE: 08/2020 LG\r\n        serverAddress = mSharedPreferencesPPServerAddress.getString(\"ServerIPAddress\", \"0\")\r\n        relativePPlanURL = mSharedPreferencesPPServerAddress.getString(\"ServerRelUrlPath\", \"0\")\r\n        //------------------------------------------------------------------\r\n\r\n        //----------------------------------------------------------------------------------------\r\n        val mSharedPreferencesCurrentTermin = view.context\r\n            .getSharedPreferences(\"examineTermin\", 0)\r\n        currentTermin = mSharedPreferencesCurrentTermin.getString(\"currentTermin\", \"0\")\r\n        //----------------------------------------------------------------------------------------\r\n        response = JSONArray()\r\n        val strServerAddress = serverAdresse.getString(\"jsondata2\", \"0\")\r\n        //second parameter is necessary ie.,Value to return if this preference does not exist.\r\n        if (strServerAddress != null) {\r\n            try {\r\n                response = JSONArray(strServerAddress)\r\n            } catch (e: JSONException) {\r\n                Log.d(\"Fehler Optionen\", \"Server-Adresse Fehler\")\r\n            }\r\n        }\r\n        var i: Int\r\n        save = false\r\n        i = 0\r\n        while (i < response?.length() ?: 0) {\r\n            run {\r\n                try {\r\n                    if ((response?.get(i).toString() == \"1\")) {\r\n                        switch2.setChecked(true)\r\n                        save = true\r\n                    } else {\r\n                        switch2.setChecked(false)\r\n                        save = false\r\n                    }\r\n                } catch (e: JSONException) {\r\n                    Log.d(\"Fehler Optionen\", \"Google Kalender aktivierung\")\r\n                }\r\n            }\r\n            i++\r\n        }\r\n\r\n        //Abfrage ob der Google kalender Ein/Ausgeschaltet ist\r\n        switch2.setOnCheckedChangeListener(object :\r\n            CompoundButton.OnCheckedChangeListener {\r\n            override fun onCheckedChanged(buttonView: CompoundButton, isChecked: Boolean) {\r\n                //TODO CHANGE TO COROUTINE\r\n                Thread(object : Runnable {\r\n                    override fun run() {\r\n                        // do something, the isChecked will be\r\n                        // true if the switch is in the On position\r\n                        if (isChecked) {\r\n                            mEditorGoogleCalendar.clear()\r\n                            mEditorGoogleCalendar.apply()\r\n                            response?.put(\"1\")\r\n                            mEditorGoogleCalendar.putString(\"jsondata2\", response.toString())\r\n                            mEditorGoogleCalendar.apply()\r\n                            val database = AppDatabase.getAppDatabase(context!!)\r\n                            val ppeList = database?.userDao()?.getFavorites(true)\r\n                            val googlecal = CheckGoogleCalendar()\r\n                            googlecal.setCtx(context)\r\n                            if (ppeList != null) {\r\n                                for (entry in ppeList) {\r\n                                    val id = entry?.id\r\n\r\n                                    //überprüfung von ein/aus Google Kalender\r\n                                    if (googlecal.checkCal(id?.toInt() ?: 0)) {\r\n                                        //ermitteln von benötigten Variablen\r\n                                        val splitDateAndTime =\r\n                                            entry?.date?.split(\" \")?.toTypedArray()\r\n                                        val splitDayMonthYear =\r\n                                            splitDateAndTime?.get(0)?.split(\"-\")?.toTypedArray()\r\n                                        course = entry?.course\r\n                                        course = course + \" \" + entry?.module\r\n                                        val timeStart =\r\n                                            splitDateAndTime?.get(1)?.substring(0, 2)?.toInt()\r\n                                        val timeEnd =\r\n                                            splitDateAndTime?.get(1)?.substring(4, 5)?.toInt()\r\n                                        calDate = GregorianCalendar(\r\n                                            splitDayMonthYear?.get(0)?.toInt() ?: 0,\r\n                                            splitDayMonthYear?.get(1)?.toInt() ?: 1 - 1,\r\n                                            splitDayMonthYear?.get(2)?.toInt() ?: 0,\r\n                                            timeStart ?: 0,\r\n                                            timeEnd ?: 0\r\n                                        )\r\n\r\n                                        //Methode zum Speichern im Kalender\r\n                                        val calendarid = calendarID(course)\r\n\r\n                                        //Funktion im Google Kalender, um PrüfID und calenderID zu speichern\r\n                                        googlecal.insertCal(id?.toInt() ?: 0, calendarid)\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (!isChecked) {\r\n                                mEditorGoogleCalendar.clear().apply()\r\n                                mEditorGoogleCalendar.remove(\"jsondata2\").apply()\r\n                            }\r\n                            Handler(Looper.getMainLooper()).post(object : Runnable {\r\n                                override fun run() {\r\n                                    Toast.makeText(\r\n                                        view.context,\r\n                                        view.context.getString(R.string.add_calendar),\r\n                                        Toast.LENGTH_SHORT\r\n                                    ).show()\r\n                                }\r\n                            })\r\n                        }\r\n                    }\r\n                }).start()\r\n            }\r\n        })\r\n\r\n        //Start Alexander Lange\r\n        //Dark mode Switch\r\n\r\n        //Start Alexander Lange\r\n        //Dark mode Switch\r\n        darkMode.setOnCheckedChangeListener(CompoundButton.OnCheckedChangeListener { compoundButton, b ->\r\n            if (b) {\r\n                AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)\r\n                return@OnCheckedChangeListener\r\n            }\r\n            AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)\r\n        })\r\n        //End Alexander Lange\r\n\r\n        //Change Listener für die Serveradresse\r\n        //speichert den neu eingegebenen Wert\r\n        /*\r\n        txtServerAddress.addTextChangedListener(new TextWatcher() {\r\n            boolean validate = false;\r\n\r\n            @Override\r\n            public void afterTextChanged(Editable s) {\r\n\r\n                String splitAdresse = txtServerAddress.getText().subSequence(0, 7).toString();\r\n                String splitAdresseEnde\r\n                        = String.valueOf(txtServerAddress\r\n                        .getText()\r\n                        .charAt(txtServerAddress.getText().length() - 1));\r\n\r\n                //System.out.println(splitAdresseEnde);\r\n\r\n                if (splitAdresse.equals(\"http://\")) {\r\n                    if (splitAdresseEnde.equals(\"/\")) {\r\n                        if (android.util.Patterns.WEB_URL.matcher(\r\n                                txtServerAddress.getText().toString()).matches()) {\r\n                            mEditorAdresse.clear();\r\n                            mEditorAdresse.apply();\r\n                            mEditorAdresse.putString(\r\n                                    \"ServerIPAddress\", txtServerAddress.getText().toString());\r\n                            mEditorAdresse.apply();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void beforeTextChanged(CharSequence s, int start,\r\n                                          int count, int after) {\r\n            }\r\n\r\n            @Override\r\n            public void onTextChanged(CharSequence s, int start,\r\n                                      int before, int count) {\r\n            }\r\n        });\r\n         */privacyDeclaration.setOnClickListener(object : View.OnClickListener {\r\n            override fun onClick(v: View) {\r\n                val ft = activity?.supportFragmentManager?.beginTransaction()\r\n                ft?.replace(R.id.frame_placeholder, PrivacyDeclarationFragment())\r\n                ft?.commit()\r\n            }\r\n        })\r\n\r\n        //interne DB löschen\r\n        btnDB.setOnClickListener(object : View.OnClickListener {\r\n            override fun onClick(v: View) {\r\n                Thread(object : Runnable {\r\n                    override fun run() {\r\n                        val database = AppDatabase.getAppDatabase(v.context)\r\n                        Log.d(\"Test\", \"Lokale DB löschen.\")\r\n                        database?.userDao()?.deleteTestPlanEntryAll()\r\n\r\n                        // Start Merlin Gürtler\r\n\r\n                        // Update nachdem löschen\r\n                        val retrofit = RetrofitConnect(relativePPlanURL ?: \"\")\r\n                        if (database != null) {\r\n                            retrofit.RetrofitWebAccess(\r\n                                context!!,\r\n                                database,\r\n                                examineYear!!,\r\n                                currentExaminePeriod!!,\r\n                                currentTermin!!,\r\n                                serverAddress!!\r\n                            )\r\n                        }\r\n                        // Ende Merlin Gürtler\r\n                        Handler(Looper.getMainLooper()).post(object : Runnable {\r\n                            override fun run() {\r\n                                Toast.makeText(\r\n                                    v.context,\r\n                                    v.context.getString(R.string.delete_db),\r\n                                    Toast.LENGTH_SHORT\r\n                                ).show()\r\n                            }\r\n                        })\r\n                    }\r\n                }).start()\r\n            }\r\n        })\r\n\r\n        //Google Kalender einträge löschen\r\n        btnCalClear.setOnClickListener(object : View.OnClickListener {\r\n            override fun onClick(v: View) {\r\n                deleteCalendar()\r\n                Toast.makeText(\r\n                    v.context,\r\n                    v.context.getString(R.string.delete_calendar),\r\n                    Toast.LENGTH_SHORT\r\n                ).show()\r\n            }\r\n        })\r\n\r\n        //Google Kalender einträge updaten\r\n        btnGoogleUpdate.setOnClickListener(object : View.OnClickListener {\r\n            override fun onClick(v: View) {\r\n                //TODO CHANGE TO COROUTINE\r\n                Thread(object : Runnable {\r\n                    override fun run() {\r\n                        updateCalendar()\r\n                    }\r\n                }).start()\r\n                Handler(Looper.getMainLooper()).post(object : Runnable {\r\n                    override fun run() {\r\n                        Toast.makeText(\r\n                            v.context,\r\n                            v.context.getString(R.string.actualisation_calendar),\r\n                            Toast.LENGTH_SHORT\r\n                        ).show()\r\n                    }\r\n                })\r\n            }\r\n        })\r\n\r\n        //Favoriten Löschen\r\n        btnFav.setOnClickListener(object : View.OnClickListener {\r\n            override fun onClick(v: View) {\r\n                Thread(object : Runnable {\r\n                    override fun run() {\r\n                        val database = AppDatabase.getAppDatabase(v.context)\r\n                        val ppeList = database?.userDao()?.getFavorites(true)\r\n                        if (ppeList != null) {\r\n                            for (entry in ppeList) {\r\n                                Log.d(\"Test Favoriten löschen.\", entry?.id?.toString() ?: \"\")\r\n                                database?.userDao()\r\n                                    ?.update(false, entry?.id?.toInt() ?: 0)\r\n                            }\r\n                        }\r\n                        Handler(Looper.getMainLooper()).post(object : Runnable {\r\n                            override fun run() {\r\n                                Toast.makeText(\r\n                                    v.context,\r\n                                    v.context.getString(R.string.delete_favorite),\r\n                                    Toast.LENGTH_SHORT\r\n                                ).show()\r\n                            }\r\n                        })\r\n                        // define an adapter\r\n                    }\r\n                }).start()\r\n            }\r\n        })\r\n    }\r\n\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater, container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View? {\r\n        val v = inflater.inflate(R.layout.optionfragment, container, false)\r\n        // Start Merlin Gürtler\r\n        // Nun aus Shared Preferences\r\n        val mSharedPreferencesValidation = container?.context?.getSharedPreferences(\"validation\", 0)\r\n        examineYear = mSharedPreferencesValidation?.getString(\"examineYear\", \"0\")\r\n        currentExaminePeriod = mSharedPreferencesValidation?.getString(\"currentPeriode\", \"0\")\r\n        returnCourse = mSharedPreferencesValidation?.getString(\"returnCourse\", \"0\")\r\n        // Ende Merlin Gürtler\r\n        return v\r\n    }\r\n\r\n    fun updatePlan(validation: String?) {\r\n        val a = PingUrl(serverAddress)\r\n    }\r\n\r\n    //Methode zum Anzeigen das keine Verbindungs zum Server möglich ist\r\n    fun noConnection() {\r\n        activity?.runOnUiThread(object : Runnable {\r\n            override fun run() {\r\n                Toast.makeText(\r\n                    context,\r\n                    context!!.getString(R.string.noConnection),\r\n                    Toast.LENGTH_SHORT\r\n                ).show()\r\n            }\r\n        })\r\n    }\r\n\r\n    // Methode zum Aktualiseren der Prüfungen\r\n    // die Abfrage Methodes des Webservers\r\n    // gibt Mögliche Änderungen wie den Status zurück,\r\n    // diese werden dann geupdated\r\n    fun updateCheckPlan() {\r\n        Thread(object : Runnable {\r\n            override fun run() {\r\n                val database = AppDatabase.getAppDatabase(context!!)\r\n\r\n\r\n                //Log.d(\"Test\",String.valueOf(pruefplanDaten.size()));\r\n                //aktuellerTermin, serverAddress, relativePPlanURL aus SharedPreferences\r\n\r\n                //retrofit auruf\r\n                val retrofit = RetrofitConnect(relativePPlanURL ?: \"\")\r\n                retrofit.retroUpdate(\r\n                    context!!,\r\n                    database!!,\r\n                    examineYear!!,\r\n                    currentExaminePeriod!!,\r\n                    currentTermin!!,\r\n                    serverAddress\r\n                )\r\n\r\n                // Log.d(\"Test3\",String.valueOf(stringaufteilung[5]));\r\n                Handler(Looper.getMainLooper()).post(object : Runnable {\r\n                    override fun run() {\r\n                        Toast.makeText(\r\n                            context,\r\n                            context!!.getString(R.string.add_favorite),\r\n                            Toast.LENGTH_SHORT\r\n                        ).show()\r\n                    }\r\n                })\r\n            }\r\n        }).start()\r\n    }\r\n\r\n    //Verbindungsaufbau zum Webserver\r\n    //Überprüfung ob Webserver erreichbar\r\n    fun PingUrl(address: String?): Boolean {\r\n        //TODO CHANGE TO COROUTINE\r\n        Thread(object : Runnable {\r\n            override fun run() {\r\n                try {\r\n                    val url = URL(address)\r\n                    val urlConn = url.openConnection() as HttpURLConnection\r\n                    urlConn.connectTimeout = 1000 * 10 // mTimeout is in seconds\r\n                    val startTime = System.currentTimeMillis()\r\n                    urlConn.connect()\r\n                    val endTime = System.currentTimeMillis()\r\n                    if (urlConn.responseCode == HttpURLConnection.HTTP_OK) {\r\n                        // System.out.println(\"Time (ms) : \" + (endTime - startTime));\r\n                        // System.out.println(\"Ping to \" + address + \" successful.\");\r\n                        updateCheckPlan()\r\n                    }\r\n                } catch (e: Exception) {\r\n                    noConnection()\r\n                }\r\n            }\r\n        }).start()\r\n        return true\r\n    }\r\n\r\n    //Google Kalender einträge löschen\r\n    fun deleteCalendar() {\r\n        val cal = CheckGoogleCalendar()\r\n        cal.setCtx(context)\r\n        cal.clearCal()\r\n    }\r\n\r\n    //Google Kalender aktualisieren\r\n    fun updateCalendar() {\r\n        val cal = CheckGoogleCalendar()\r\n        cal.setCtx(context)\r\n        cal.updateCal()\r\n    }\r\n\r\n    fun calendarID(eventtitle: String?): Int {\r\n        val event = ContentValues()\r\n        event.put(CalendarContract.Events.CALENDAR_ID, 2)\r\n        event.put(CalendarContract.Events.TITLE, course)\r\n        event.put(CalendarContract.Events.DESCRIPTION, context!!.getString(R.string.fh_name))\r\n        event.put(CalendarContract.Events.DTSTART, calDate.timeInMillis)\r\n        event.put(CalendarContract.Events.DTEND, calDate.timeInMillis + (90 * 60000))\r\n        event.put(CalendarContract.Events.ALL_DAY, 0) // 0 for false, 1 for true\r\n        event.put(CalendarContract.Events.HAS_ALARM, 0) // 0 for false, 1 for true\r\n        val timeZone = TimeZone.getDefault().id\r\n        event.put(CalendarContract.Events.EVENT_TIMEZONE, timeZone)\r\n        val baseUri = Uri.parse(\"content://com.android.calendar/events\")\r\n        context?.contentResolver?.insert(baseUri, event)\r\n        var result = 0\r\n        val projection = arrayOf(\"_id\", \"title\")\r\n        val cursor = context?.contentResolver\r\n            ?.query(\r\n                baseUri, null,\r\n                null, null, null\r\n            )\r\n        if (cursor!!.moveToFirst()) {\r\n            var calName: String?\r\n            var calID: String\r\n            val nameCol = cursor.getColumnIndex(projection[1])\r\n            val idCol = cursor.getColumnIndex(projection[0])\r\n            do {\r\n                calName = cursor.getString(nameCol)\r\n                calID = cursor.getString(idCol)\r\n                if (calName != null && calName.contains((eventtitle)!!)) {\r\n                    result = calID.toInt()\r\n                }\r\n            } while (cursor.moveToNext())\r\n            cursor.close()\r\n        }\r\n        return (result)\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/Optionen.kt b/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/Optionen.kt
--- a/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/Optionen.kt	
+++ b/app/src/main/java/com/Fachhochschulebib/fhb/pruefungsplaner/Optionen.kt	
@@ -118,12 +118,6 @@
         })
 
         //layout Komponenten
-        //TODO REMOVE val btnDb = v.findViewById<View>(R.id.btnDB) as Button
-        //TODO REMOVE val btnFav = v.findViewById<View>(R.id.btnFav) as Button
-        //TODO REMOVE val btnGoogleloeschen = v.findViewById<View>(R.id.btnCalClear) as Button
-        //TODO REMOVE val btnGoogleupdate = v.findViewById<View>(R.id.btnGoogleUpdate) as Button
-        //TODO REMOVE val SWgooglecalender = v.findViewById<View>(R.id.switch2) as Switch
-        //TODO REMOVE val privacyDeclaration = v.findViewById<View>(R.id.privacyDeclaration) as Button
         //holder.zahl1 = position;
         val serverAdresse = view.context.getSharedPreferences("json8", 0)
         //Creating editor to store uebergebeneModule to shared preferences
